#[cfg(test)]
mod tests;

use vi::processor::{LetterModification, ToneMark};

const MAX_CHAR_IN_VNWORD: usize = "nghieeng".len().next_power_of_two();

pub trait SingleByteCharset {}
pub trait DoubleByteCharset {}

impl SingleByteCharset for Tcvn3<'_> {}
impl SingleByteCharset for Viscii<'_> {}
impl DoubleByteCharset for Vni<'_> {}

pub struct Viqr<'a>(&'a [u8]);

#[derive(Debug)]
enum State {
    InWord,
    WaitingModifier,
    Escaping,
    Finished,
}

fn is_vowel(b: u8) -> bool {
    b"aeiyuoAEIYUO".contains(&b)
}

#[allow(non_snake_case)]
fn is_A_z(b: u8) -> bool {
    match b {
        b'A'..=b'Z' => true,
        b'a'..=b'z' => true,
        _ => false,
    }
    // b.is_ascii_alphabetic()
}

fn maybe_tone_mark(b: u8) -> Option<ToneMark> {
    use ToneMark::*;
    let mark = match b {
        b'\'' => Acute,
        b'`' => Grave,
        b'?' => HookAbove,
        b'~' => Tilde,
        b'.' => Underdot,
        _ => return None,
    };
    Some(mark)
}

fn maybe_letter_modifier(b: u8) -> Option<LetterModification> {
    use LetterModification::*;
    let modifier = match b {
        b'(' => Breve,
        b'^' => Circumflex,
        b'+' => Horn,
        b'd' | b'D' => Dyet,
        _ => return None,
    };
    Some(modifier)
}

fn viqr_inner(word: &mut String, state: &mut State, b: u8) {
    use vi::processor::Transformation::*;
    use vi::processor::{add_tone_char, modify_letter};
    use State::*;
    word.push(b as char);
    match state {
        InWord => {
            if is_vowel(b) || b == b'd' || b == b'D' {
                // dbg!(b as char);
                *state = WaitingModifier;
            } else if b == b'\\' {
                *state = Escaping;
            } else if is_A_z(b) {
            } else {
                *state = Finished;
            }
        }
        WaitingModifier => {
            if let Some(mark) = maybe_tone_mark(b) {
                let _mark = word.pop();
                let ch = word.pop().unwrap();
                let new = add_tone_char(ch, &mark);
                word.push(new);
                *state = InWord;
            } else if let Some(tone) = maybe_letter_modifier(b) {
                let _ = word.pop();
                match dbg!(modify_letter(word, &tone)) {
                    Ignored => {
                        word.push(b as char);
                    }
                    _ => {}
                }
            } else if is_vowel(b) {
            } else if is_A_z(b) {
                *state = InWord;
            } else if b == b'\\' {
                *state = Escaping;
            } else {
                *state = Finished;
            }
        }
        Escaping => {
            let ch = word.pop().unwrap();
            let _ = word.pop();
            word.push(ch);
            *state = Finished;
        }
        _ => {}
    }
}

impl<'a> Viqr<'a> {
    pub fn from_bytes(bytes: &'a [u8]) -> Self {
        Self(bytes)
    }

    #[track_caller]
    pub fn encode_utf8(&self) -> String {
        use State::*;
        let mut out = String::with_capacity(self.0.len());
        let mut word = String::with_capacity(MAX_CHAR_IN_VNWORD);
        let mut state = InWord;

        for &b in self.0 {
            viqr_inner(&mut word, &mut state, b);
            match state {
                InWord => {}
                WaitingModifier => {}
                Escaping => {}
                Finished => {
                    out.push_str(&*word);
                    word.clear();
                    state = InWord;
                }
            }
        }
        out
    }
}

// Despite the growing popularity of Unicode in computing,
// the VNI Encoding is still in wide use by Vietnamese speakers
// both in Vietnam and abroad.
// The VNI encoding was used extensively in the south of Vietnam,
// and sometimes used overseas, while TCVN 5712 was dominant in the north
pub struct Vni<'a>(&'a [u8]);

impl<'a> Vni<'a> {
    pub fn from_bytes(bytes: &'a [u8]) -> Self {
        Self(bytes)
    }

    pub fn encode_utf8(&self) -> String {
        unimplemented!()
    }
}

// VISCII was mostly used by overseas Vietnamese speakers,
// with VSCII (TCVN) being more popular in northern Vietnam and
// VNI being more popular in southern Vietnam.
pub struct Viscii<'a>(&'a [u8]);

impl<'a> Viscii<'a> {
    pub fn from_bytes(bytes: &'a [u8]) -> Self {
        Self(bytes)
    }

    pub fn encode_utf8(&self) -> String {
        let mut out = String::with_capacity(self.0.len() * 2);
        for &b in self.0 {
            let u = TABVISCII[b as usize];
            let ch = unsafe { char::from_u32_unchecked(u) };
            out.push(ch);
        }
        out
    }
}

/// VSCII-3, also known as TCVN 5712-3, VN3 or simply TCVN3.
/// VSCII (TCVN) was used extensively in the north of Vietnam.
pub struct Tcvn3<'a>(&'a [u8]);

impl<'a> Tcvn3<'a> {
    pub fn from_bytes(bytes: &'a [u8]) -> Self {
        Self(bytes)
    }

    pub fn encode_utf8(&self) -> String {
        let mut out = String::with_capacity(self.0.len() * 2);
        for &b in self.0 {
            let u = AS_UNICODE[b as usize];
            let ch = unsafe { char::from_u32_unchecked(u) };
            out.push(ch);
        }
        out
    }
}

// grep from <http://www.informatik.uni-leipzig.de/~duc/software/misc/tcvn.txt>
#[rustfmt::skip]
static AS_UNICODE: [u32; 0x100] = [
    0x00,0xda,0x1ee4,0x03,0x1eea,0x1eec,0x1eee,0x07,    // 00
    0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,            // 08
    0x10,0x1ee8,0x1ef0,0x1ef2,0x1ef6,0x1ef8,0xdd,0x1ef4,// 10
    0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,            //
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,            // 20
    0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,            //
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,            // 30
    0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,            //
    0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,            // 40
    0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,            //
    0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,            // 50
    0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,            //
    0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,            // 60
    0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,            //
    0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,            // 70
    0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,            //
    0xc0,0x1ea2,0xc3,0xc1,0x1ea0,0x1eb6,0x1eac,0xc8,    // 80
    0x1eba,0x1ebc,0xc9,0x1eb8,0x1ec6,0xcc,0x1ec8,0x0128,//
    0xcd,0x1eca,0xd2,0x1ece,0xd5,0xd3,0x1ecc,0x1ed8,    // 90
    0x1edc,0x1ede,0x1ee0,0x1eda,0x1ee2,0xd9,0x1ee6,0x0168,
    0xa0,0x0102,0xc2,0xca,0xd4,0x01a0,0x01af,0x0110,    // A0
    0x0103,0xe2,0xea,0xf4,0x01a1,0x01b0,0x0111,0x1eb0,  //
    0x0300,0x0309,0x0303,0x0301,0x0323,0xe0,0x1ea3,0xe3,// B0
    0xe1,0x1ea1,0x1eb2,0x1eb1,0x1eb3,0x1eb5,0x1eaf,0x1eb4,//
    0x1eae,0x1ea6,0x1ea8,0x1eaa,0x1ea4,0x1ec0,0x1eb7,0x1ea7,// C0
    0x1ea9,0x1eab,0x1ea5,0x1ead,0xe8,0x1ec2,0x1ebb,0x1ebd,
    0xe9,0x1eb9,0x1ec1,0x1ec3,0x1ec5,0x1ebf,0x1ec7,0xec,// D0
    0x1ec9,0x1ec4,0x1ebe,0x1ed2,0x0129,0xed,0x1ecb,0xf2,
    0x1ed4,0x1ecf,0xf5,0xf3,0x1ecd,0x1ed3,0x1ed5,0x1ed7,// E0
    0x1ed1,0x1ed9,0x1edd,0x1edf,0x1ee1,0x1edb,0x1ee3,0xf9,
    0x1ed6,0x1ee7,0x0169,0xfa,0x1ee5,0x1eeb,0x1eed,0x1eef, // F0
    0x1ee9,0x1ef1,0x1ef3,0x1ef7,0x1ef9,0xfd,0x1ef5,0x1ed0,
];

// grep from <https://vietstd.sourceforge.net/document/unicode.html>
#[rustfmt::skip]
static TABVISCII: [u32; 0x100] = [
    0x0000, 0x0001, 0x1EB2, 0x0003, 0x0004, 0x1EB4, 0x1EAA, 0x0007, // 0x00
    0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f, // 0x08
    0x0010, 0x0011, 0x0012, 0x0013, 0x1EF6, 0x0015, 0x0016, 0x0017, // 0x10
    0x0018, 0x1EF8, 0x001a, 0x001b, 0x001c, 0x001d, 0x1EF4, 0x001f, // 0x18
    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, // 0x20
    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, // 0x28
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, // 0x30
    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f, // 0x38
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, // 0x40
    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f, // 0x48
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, // 0x50
    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f, // 0x58
    0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, // 0x60
    0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, // 0x68
    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, // 0x70
    0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f, // 0x78
    0x1EA0, 0x1EAE, 0x1EB0, 0x1EB6, 0x1EA4, 0x1EA6, 0x1EA8, 0x1EAC, // 0x80
    0x1EBC, 0x1EB8, 0x1EBE, 0x1EC0, 0x1EC2, 0x1EC4, 0x1EC6, 0x1ED0, // 0x88
    0x1ED2, 0x1ED4, 0x1ED6, 0x1ED8, 0x1EE2, 0x1EDA, 0x1EDC, 0x1EDE, // 0x90
    0x1ECA, 0x1ECE, 0x1ECC, 0x1EC8, 0x1EE6, 0x0168, 0x1EE4, 0x1EF2, // 0x98
    0x00D5, 0x1EAF, 0x1EB1, 0x1EB7, 0x1EA5, 0x1EA7, 0x1EA9, 0x1EAD, // 0xA0
    0x1EBD, 0x1EB9, 0x1EBF, 0x1EC1, 0x1EC3, 0x1EC5, 0x1EC7, 0x1ED1, // 0xA8
    0x1ED3, 0x1ED5, 0x1ED7, 0x1EE0, 0x01A0, 0x1ED9, 0x1EDD, 0x1EDF, // 0xB0
    0x1ECB, 0x1EF0, 0x1EE8, 0x1EEA, 0x1EEC, 0x01A1, 0x1EDB, 0x01AF, // 0xB8
    0x00C0, 0x00C1, 0x00C2, 0x00C3, 0x1EA2, 0x0102, 0x1EB3, 0x1EB5, // 0xC0
    0x00C8, 0x00C9, 0x00CA, 0x1EBA, 0x00CC, 0x00CD, 0x0128, 0x1EF3, // 0xC8
    0x0110, 0x1EE9, 0x00D2, 0x00D3, 0x00D4, 0x1EA1, 0x1EF7, 0x1EEB, // 0xD0
    0x1EED, 0x00D9, 0x00DA, 0x1EF9, 0x1EF5, 0x00DD, 0x1EE1, 0x01B0, // 0xD8
    0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x1EA3, 0x0103, 0x1EEF, 0x1EAB, // 0xE0
    0x00E8, 0x00E9, 0x00EA, 0x1EBB, 0x00EC, 0x00ED, 0x0129, 0x1EC9, // 0xE8
    0x0111, 0x1EF1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x1ECF, 0x1ECD, // 0xF0
    0x1EE5, 0x00F9, 0x00FA, 0x0169, 0x1EE7, 0x00FD, 0x1EE3, 0x1EEE, // 0xF8
];
